#!/usr/bin/env perl

use strict;
use warnings;
use feature qw(say state);

use FindBin qw();
use Getopt::Long qw(GetOptions Configure);
use Pod::Usage qw(pod2usage);

use constant DICT => '/tmp/wordsetc.jsonl';
use constant BIN  => "$FindBin::Bin/../bin/wordsetc";

#-------------------------------------------------------------------------------
# Arguments
#-------------------------------------------------------------------------------
my $TILES;
my $BOARD;

Configure("no_ignore_case");

GetOptions(
  'help|h'       => sub { pod2usage({ -verbose => 2, -exitval => 0 }) },
  'short-help|H' => sub { print "does a thing"; exit 0 },
  'tiles|t=s'    => \$TILES,
  'board|b=s'    => \$BOARD,
) or pod2usage({ -verbose => 0, -exitval => 1 });

die "required: --tiles\n"
  unless defined $TILES;

die "invalid: '$TILES' - tiles may only include a-zA-Z and ? (blank tile)\n"
  if $TILES !~ /^[\?a-zA-Z]+$/;

die "A maximum of 3 wildcards is permitted\n"
  if ($TILES =~ tr/?//) > 3;

die "invalid: '$_' - the board pattern may only include a-zA-Z and _ for an empty space\n"
  if defined $BOARD
  && $BOARD !~ /^[_a-zA-Z]+$/;

die "invalid: '$_' - the board pattern must include at least one empty space\n"
  if defined $BOARD
  && $BOARD !~ /_/;

#-------------------------------------------------------------------------------
# External dependencies
#-------------------------------------------------------------------------------
unless (-f DICT) {
  warn "The dictionary file is missing. You can create it by running:\n\n\twordsetc rebuild\n";
  exit 1;
}

#-------------------------------------------------------------------------------
# Subroutines
#-------------------------------------------------------------------------------
sub words {
  my $tiles = shift;

  open my $fh, '-|', BIN . " anagrams --tiles '$tiles'"
    or die "Can't open pipe to wordsetc: $!";

  return sub{
    if (defined(my $word = <$fh>)) {
      chomp $word;
      return $word;
    }

    return;
  };
}

#-------------------------------------------------------------------------------
# Uses `terms` to filter the dictionary for entries that fit the user's board.
# `terms` prepends a "subkey" of the characters in the word, less the
# characters being used from the board, to each line. This allows us to use a
# simple match against the key built from the user's tiles to match the word to
# the line.
#-------------------------------------------------------------------------------
sub search_with_board {
  my $needle = shift;
  my $board  = shift;

  state %terms = do{
    my %terms;

    open my $fh, '-|', BIN . " terms --board '$board'"
      or die "Can't open pipe to wordsetc: $!";

    while (defined(my $line = <$fh>)) {
      chomp $line;

      # Extract the char-sorted word key from the line
      my ($key) = $line =~ /^([^:]+)/;

      $terms{$key} = $line;
    }

    close $fh;

    %terms;
  };

  for my $key (keys %terms) {
    return $terms{$key}
      if $key eq $needle;
  }

  return;
}

#-------------------------------------------------------------------------------
# Binary search for the word in the dictionary. Prepends the word key to the
# line, despite it being duplication of the key already prepended to the line
# when the dictionary is built, to match the output of `search_with_board` (see
# comments in that subroutine).
#-------------------------------------------------------------------------------
sub search_without_board {
  my $needle = shift;

  open my $fh, '<', DICT
    or die "Can't open " . DICT . ": $!";

  my $file_size = -s $fh;
  my ($left, $right) = (0, $file_size);
  my $found;

  while ($left <= $right) {
    my $mid = int(($left + $right) / 2);

    # Seek to the middle position in bytes
    seek $fh, $mid, 0;

    # Read forward to the next newline to ensure we're at the start of a line,
    # but not if we're at the start of the file.
    <$fh> if $mid != 0;

    # Read the line
    my $line = <$fh>;

    # If we've reached the end of the file without finding a match, break
    last unless defined $line;

    chomp $line;

    # Extract the word from the line
    my ($word) = $line =~ /^([^:]+)/;

    # Move the left boundary to the current position
    if ($word lt $needle) {
      $left = tell $fh;
    }
    # Move the right boundary to just before the mid position
    elsif ($word gt $needle) {
      $right = $mid - 1;
    }
    # Found the word
    else {
      $found = "$needle:$line";
      last;
    }
  }

  close $fh;

  return $found;
}

sub search {
  my $needle = shift;
  my $board  = shift;

  if (defined $board) {
    search_with_board($needle, $board);
  } else {
    search_without_board($needle);
  }
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
my $words = words($TILES);

while (defined(my $key = $words->())) {
  if (defined(my $line = search($key, $BOARD))) {
    say $line;
  }
}

__DATA__

=head1 NAME

solve - finds sorted word keys in the dictionary

=head1 SYNOPSIS

wordsetc solve TILES_STRING

=head1 OPTIONS

=over 4

=item B<--help | -h>

Prints a brief help message and exits.

=item B<--tiles | -t>

The string of tiles to use for the search. The tiles string may only include
characters a-zA-Z or ? for a blank tile/wildcard.

=item B<--board | -b>

The board pattern to use for the search. The board pattern may only include
characters a-zA-Z or _ for an empty space. The board pattern must include at
least one empty space.

=back

=cut
