#!/usr/bin/env perl

use strict;
use warnings;
use feature qw(say);

use FindBin qw();
use Pod::Usage qw(pod2usage);

use constant DICT => '/tmp/wordsetc.jsonl';
use constant BIN  => "$FindBin::Bin/../bin/wordsetc";

#-------------------------------------------------------------------------------
# Arguments
#-------------------------------------------------------------------------------
for (@ARGV) {
  if (/--help/ || /-h/) {
    pod2usage({ -verbose => 2, -exitval => 0 });
  }

  if (/--short-help/ || /-H/) {
    print "does a thing";
    exit 0;
  }

  if ($_ !~ /^[a-zA-Z]+$/) {
    pod2usage({ -verbose => 0, -exitval => 1, -message => "invalid: '$_' - letter sets may only include a-zA-Z\n"});
  }
}

#-------------------------------------------------------------------------------
# External dependencies
#-------------------------------------------------------------------------------
unless (-f DICT) {
  warn "The dictionary file is missing. You can create it by running:\n\n\twordsetc rebuild\n";
  exit 1;
}

#-------------------------------------------------------------------------------
# Subroutines
#-------------------------------------------------------------------------------
sub words {
  my $tiles = shift;

  open my $fh, '-|', BIN . " expand '$tiles'"
    or die "Can't open pipe to wordsetc: $!";

  return sub{
    if (defined(my $word = <$fh>)) {
      chomp $word;
      return $word;
    }

    return;
  };
}

sub search {
  my ($needle) = @_;

  open my $fh, '<', DICT
    or die "Can't open " . DICT . ": $!";

  my $file_size = -s $fh;
  my ($left, $right) = (0, $file_size);
  my $found;

  while ($left <= $right) {
    my $mid = int(($left + $right) / 2);

    # Seek to the middle position in bytes
    seek $fh, $mid, 0;

    # Read forward to the next newline to ensure we're at the start of a line,
    # but not if we're at the start of the file.
    <$fh> if $mid != 0;

    # Read the line
    my $line = <$fh>;

    # If we've reached the end of the file without finding a match, break
    last unless defined $line;

    chomp $line;

    # Extract the word from the line
    my ($word) = $line =~ /^([^:]+)/;

    # Move the left boundary to the current position
    if ($word lt $needle) {
      $left = tell $fh;
    }
    # Move the right boundary to just before the mid position
    elsif ($word gt $needle) {
      $right = $mid - 1;
    }
    # Found the word
    else {
      $found = $line;
      $found =~ s/^[^:]*?://;
      last;
    }
  }

  close $fh;
  return $found;
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
my $words = words(shift @ARGV);

while (defined(my $word = $words->())) {
  if (defined(my $line = search($word))) {
    say $line;
  }
}

__DATA__

=head1 NAME

solve - finds sorted word keys in the dictionary

=head1 SYNOPSIS

wordsetc solve TILES_STRING

=head1 OPTIONS

=over 4

=item B<--help>

Prints a brief help message and exits.

=back

=cut
